# -*- coding: utf-8 -*-
"""
/***************************************************************************
 TimeSeriesViewingToolDialog
                                 A QGIS plugin
 A tool to view time series images
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-03-18
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Chaoying Lin
        email                : 1754129@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from PyQt5.QtCore import QSize, Qt
from PyQt5.QtWidgets import QHeaderView, QTableWidget, QMessageBox, QLineEdit, QPushButton, QFileDialog, \
    QTableWidgetItem, QAbstractItemView, QComboBox, QTabWidget
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.PyQt.QtGui import QIcon, QPixmap

PLUGIN_PATH = os.path.dirname(__file__)
# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'time_series_viewing_tool_dialog_base.ui'))


class TimeSeriesViewingToolDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(TimeSeriesViewingToolDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.tifFiles = []
        self.initUI()
        self.pbSelectDir.clicked.connect(self.onpbSelectDirClicked)
        self.pbAdd.clicked.connect(self.onpbAddClicked)
        self.pbClear.clicked.connect(self.onpbClearClicked)
        self.pbInsert.clicked.connect(self.onpbInsertClicked)
        self.pbDelete.clicked.connect(self.onpbDeleteClicked)
        self.pbUp.clicked.connect(self.onpbUpClicked)
        self.pbDown.clicked.connect(self.onpbDownClicked)

    def onpbSelectDirClicked(self):
        imgsFolderDialog = QFileDialog(self)
        imgsFolderDialog.setFileMode(QFileDialog.DirectoryOnly)
        imgsFolderDir = imgsFolderDialog.getExistingDirectory(caption="选择时序影像目录")
        self.leImagesDir.setText(imgsFolderDir)
        return

    def initUI(self):
        self.pbAdd.setIconSize(QSize(20, 20))
        self.pbAdd.setIcon(QIcon(QPixmap(f"{PLUGIN_PATH}/icons/添加.png")))
        self.pbAdd.setText("添加")
        self.pbClear.setIconSize(QSize(20, 20))
        self.pbClear.setIcon(QIcon(f"{PLUGIN_PATH}/icons/清空.png"))
        self.pbClear.setText("清空")
        self.pbInsert.setIconSize(QSize(20, 20))
        self.pbInsert.setIcon(QIcon(rf"{PLUGIN_PATH}/icons/插入.png"))
        self.pbInsert.setText("插入")
        self.pbDelete.setIconSize(QSize(20, 20))
        self.pbDelete.setIcon(QIcon(rf"{PLUGIN_PATH}/icons/删除.png"))
        self.pbDelete.setText("删除")
        self.pbUp.setIconSize(QSize(20, 20))
        self.pbUp.setIcon(QIcon(rf"{PLUGIN_PATH}/icons/上移.png"))
        self.pbUp.setText("上移")
        self.pbDown.setIconSize(QSize(20, 20))
        self.pbDown.setIcon(QIcon(rf"{PLUGIN_PATH}/icons/下移.png"))
        self.pbDown.setText("下移")
        QLineEdit.setPlaceholderText(self.leImagesDir, "请输入影像目录")
        QTableWidget.setSelectionBehavior(self.tbImages, QTableWidget.SelectRows)
        self.cbExportFormat.addItem('.csv')
        self.cbExportFormat.addItem('.xls')
        self.cbExportFormat.addItem('.shp')
        QTableWidget.setEditTriggers(self.tbRecords, QAbstractItemView.NoEditTriggers)
        QTableWidget.resizeColumnsToContents(self.tbRecords)
        self.recordsNum = 0
        return

    def onpbAddClicked(self):
        imgsFolderDir = self.leImagesDir.text()
        if not (os.path.exists(imgsFolderDir)):
            QMessageBox.critical(self, "错误", "影像目录不存在！", QMessageBox.Yes, QMessageBox.Yes)
            QLineEdit.setFocus(self.leImagesDir)
            return
        files = os.listdir(imgsFolderDir)
        self.tifFiles = list(filter(lambda file: file.endswith('.tif'), files))
        # self.tifFiles = [f'{imgsFolderDir}/{tif}' for tif in self.tifFiles]
        self.tifFiles = [os.path.join(imgsFolderDir + '/', tif) for tif in self.tifFiles]
        print(imgsFolderDir)

        self.__addImages()
        return

    def __addImages(self):
        self.tbImages.setRowCount(len(self.tifFiles))
        self.tbImages.setColumnCount(2)
        self.tbImages.setHorizontalHeaderLabels(['影像序号', '影像路径'])
        for index, tif in enumerate(self.tifFiles):
            numItem = QtWidgets.QTableWidgetItem(str(index + 1))
            numItem.setTextAlignment(Qt.AlignCenter)
            imgPathItem = QtWidgets.QTableWidgetItem(tif)
            imgPathItem.setTextAlignment(Qt.AlignCenter)
            self.tbImages.setItem(index, 0, numItem)
            self.tbImages.setItem(index, 1, imgPathItem)
        self.tbImages.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        QTableWidget.setEditTriggers(self.tbImages, QAbstractItemView.NoEditTriggers)
        self.inittbRecords()
        return

    def onpbClearClicked(self):
        flag = QMessageBox.warning(self, "警告", "是否清空影像列表？", QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)
        if flag != QMessageBox.Yes:
            return
        QtWidgets.QTableWidget.clear(self.tbImages)
        self.tbImages.setHorizontalHeaderLabels(['影像序号', '影像路径'])
        return

    def onpbInsertClicked(self):
        imgInsertDialog = QFileDialog(self)
        imgInsertDialog.setAcceptMode(QFileDialog.AcceptOpen)
        imgInsertDialog.setFileMode(QFileDialog.ExistingFile)
        imgInsert, _ = imgInsertDialog.getOpenFileName(self, "选择要插入的影像", "./", "影像 (*.tif *.TIF)")
        if imgInsert == '':
            return
        items = QTableWidget.selectedItems(self.tbImages)
        if items:
            itemIndex = items[0]
            index = int(QTableWidgetItem.text(itemIndex))
            self.tifFiles.insert(index - 1, imgInsert)
            self.__addImages()
            QTableWidget.selectRow(self.tbImages, index - 1)
        else:
            self.tifFiles.append(imgInsert)
            self.__addImages()
            QTableWidget.selectRow(self.tbImages, len(self.tifFiles) - 1)
        return

    def onpbDeleteClicked(self):
        items = QTableWidget.selectedItems(self.tbImages)
        if items:
            indexItems = items[0::2]
            for indexItem in indexItems:
                index = int(indexItem.text())
                self.tifFiles.pop(index - 1)
            self.__addImages()
            QMessageBox.information(self, "删除", "删除成功！", QMessageBox.Yes, QMessageBox.Yes)
        else:
            QMessageBox.information(self, "删除", "请选在待删除影像所在行后，再按删除按钮！", QMessageBox.Yes, QMessageBox.Yes)
        self.tbImages.clearSelection()
        return

    def onpbDownClicked(self):
        items = QTableWidget.selectedItems(self.tbImages)
        if items:
            indexItems = items[0::2]
            indexStart = int(indexItems[0].text())
            indexEnd = int(indexItems[-1].text())
            if indexEnd == len(self.tifFiles):
                QMessageBox.information(self, "移动", "已到达表尾！", QMessageBox.Yes, QMessageBox.Yes)
            else:
                tifFile = self.tifFiles.pop(indexEnd)
                self.tifFiles.insert(indexStart - 1, tifFile)
                self.__addImages()
                self.tbImages.clearSelection()
                for index in range(indexStart + 1, indexEnd + 2):
                    itemNum = QTableWidget.item(self.tbImages, index - 1, 0)
                    itemNum.setSelected(True)
                    itemImagePath = QTableWidget.item(self.tbImages, index - 1, 1)
                    itemImagePath.setSelected(True)
        else:
            QMessageBox.Warning(self, "警告", "请选中待移动位置影像所在行，再进行该操作!", QMessageBox.Yes, QMessageBox.Yes)
        return

    def onpbUpClicked(self):
        items = QTableWidget.selectedItems(self.tbImages)
        if items:
            indexItems = items[0::2]
            indexStart = int(indexItems[0].text())
            indexEnd = int(indexItems[-1].text())
            if indexStart == 1:
                QMessageBox.information(self, "移动", "已到达表头！", QMessageBox.Yes, QMessageBox.Yes)
            else:
                tifFile = self.tifFiles.pop(indexStart - 2)
                self.tifFiles.insert(indexEnd - 1, tifFile)
                self.__addImages()
                self.tbImages.clearSelection()
                for index in range(indexStart - 1, indexEnd):
                    itemNum = QTableWidget.item(self.tbImages, index - 1, 0)
                    itemNum.setSelected(True)
                    itemImagePath = QTableWidget.item(self.tbImages, index - 1, 1)
                    itemImagePath.setSelected(True)
        else:
            QMessageBox.Warning(self, "警告", "请选中待移动位置影像所在行，再进行该操作!", QMessageBox.Yes, QMessageBox.Yes)
        return

    def inittbRecords(self):
        if self.recordsNum:
            flag = QMessageBox.warning(self, "警告", "是否需要保存现有时序记录？", QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)
            if flag == QMessageBox.Yes:
                QTabWidget.setCurrentIndex(self.tabContainer, 2)
                return
            else:
                QTableWidget.clear(self.tbRecords)
        QTableWidget.setRowCount(self.tbRecords, 15)
        QTableWidget.setColumnCount(self.tbRecords, len(self.tifFiles) + 2)
        headerLabels = ['x', 'y']
        for tif in self.tifFiles:
            headerLabels.append(os.path.basename(tif)[0:-4])
        QTableWidget.setHorizontalHeaderLabels(self.tbRecords, headerLabels)
        self.recordsNum = 0
